// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/lib/pq"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (is_done)
VALUES ($1)
RETURNING id, is_done
`

func (q *Queries) CreateOrder(ctx context.Context, isDone bool) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder, isDone)
	var i Order
	err := row.Scan(&i.ID, &i.IsDone)
	return i, err
}

const createOrderItems = `-- name: CreateOrderItems :one
INSERT INTO order_items (order_id, item_id)
VALUES ($1, $2)
RETURNING id
`

type CreateOrderItemsParams struct {
	OrderID string `json:"order_id"`
	ItemID  int32  `json:"item_id"`
}

func (q *Queries) CreateOrderItems(ctx context.Context, arg CreateOrderItemsParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createOrderItems, arg.OrderID, arg.ItemID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getOrder = `-- name: GetOrder :one
SELECT id AS order_id, is_done as done
FROM orders
WHERE id = $1
LIMIT 1
`

type GetOrderRow struct {
	OrderID string `json:"order_id"`
	Done    bool   `json:"done"`
}

func (q *Queries) GetOrder(ctx context.Context, id string) (GetOrderRow, error) {
	row := q.db.QueryRowContext(ctx, getOrder, id)
	var i GetOrderRow
	err := row.Scan(&i.OrderID, &i.Done)
	return i, err
}

const getOrderStatus = `-- name: GetOrderStatus :one
SELECT is_done AS done
FROM orders
WHERE id = $1
`

func (q *Queries) GetOrderStatus(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, getOrderStatus, id)
	var done bool
	err := row.Scan(&done)
	return done, err
}

const getOrderWithItemIds = `-- name: GetOrderWithItemIds :one
SELECT orders.id, orders.is_done, ARRAY_AGG(oi.id)::int[] AS item_ids
FROM orders
         JOIN order_items oi ON orders.id = oi.order_id
WHERE orders.id = $1
GROUP BY orders.id
LIMIT 1
`

type GetOrderWithItemIdsRow struct {
	ID      string  `json:"id"`
	IsDone  bool    `json:"is_done"`
	ItemIds []int32 `json:"item_ids"`
}

func (q *Queries) GetOrderWithItemIds(ctx context.Context, id string) (GetOrderWithItemIdsRow, error) {
	row := q.db.QueryRowContext(ctx, getOrderWithItemIds, id)
	var i GetOrderWithItemIdsRow
	err := row.Scan(&i.ID, &i.IsDone, pq.Array(&i.ItemIds))
	return i, err
}

const listOrders = `-- name: ListOrders :many
SELECT orders.id AS order_id, orders.is_done as done
FROM orders
`

type ListOrdersRow struct {
	OrderID string `json:"order_id"`
	Done    bool   `json:"done"`
}

func (q *Queries) ListOrders(ctx context.Context) ([]ListOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersRow{}
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(&i.OrderID, &i.Done); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByDone = `-- name: ListOrdersByDone :many
SELECT orders.id AS order_id, orders.is_done as done
FROM orders
WHERE is_done = $1
`

type ListOrdersByDoneRow struct {
	OrderID string `json:"order_id"`
	Done    bool   `json:"done"`
}

func (q *Queries) ListOrdersByDone(ctx context.Context, isDone bool) ([]ListOrdersByDoneRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByDone, isDone)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersByDoneRow{}
	for rows.Next() {
		var i ListOrdersByDoneRow
		if err := rows.Scan(&i.OrderID, &i.Done); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setOrderDone = `-- name: SetOrderDone :exec
UPDATE orders
SET is_done = true
WHERE id = $1
`

func (q *Queries) SetOrderDone(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, setOrderDone, id)
	return err
}
